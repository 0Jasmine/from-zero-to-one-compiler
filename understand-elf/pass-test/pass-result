
1c1
< ; ModuleID = './understand-elf/pass-test/argpromotion.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/sccp.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-simplify.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/always-inline.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/licm.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-unroll.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-unroll-and-jam.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/mergereturn.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/sroa.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-deletion.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/break-crit-edges.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,42c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %._crit_edge, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %._crit_edge ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %._crit_edge, !llvm.loop !9
< 
< ._crit_edge:                                      ; preds = %9
<   br label %3
< 
< 13:                                               ; preds = %._crit_edge1, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %._crit_edge1 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %._crit_edge1, !llvm.loop !12
---
>   br label %1
44,45c12,34
< ._crit_edge1:                                     ; preds = %13
<   br label %13
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
47,48c36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 19:                                               ; preds = %7
52,57d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
59,62c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
65c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
68,74c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
84,91c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/function-attrs.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/codegenprepare.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,42c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %2
< 
< 2:                                                ; preds = %9, %0
<   %3 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %4 = bitcast i8* %1 to i32*
<   %5 = trunc i64 %3 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %4, i64 %3
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %3 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %3, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %23, label %2, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %2
<   %14 = phi i32 [ 0, %2 ], [ %21, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %sunkaddr = mul i64 %3, 4
<   %sunkaddr1 = getelementptr inbounds i8, i8* %1, i64 %sunkaddr
<   %17 = bitcast i8* %sunkaddr1 to i32*
<   %18 = load i32, i32* %17, align 4, !tbaa !5
<   %19 = mul nsw i32 %18, %16
<   %20 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %19)
<   %21 = add nuw nsw i32 %14, 1
<   %22 = icmp eq i32 %21, 1000
<   br i1 %22, label %9, label %13, !llvm.loop !12
---
>   br label %1
44,45c12,36
< 23:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
49,54d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
56,59c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
62c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
65,71c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
81,88c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/partial-inliner.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/deadargelim.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/inline.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/strip-nondebug.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
6c6
< @0 = private unnamed_addr constant [4 x i8] c"%d \00", align 1
---
> @.str = private unnamed_addr constant [4 x i8] c"%d \00", align 1
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @0, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/reassociate.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %16, %17
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/globalopt.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/reg2mem.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,65c10,28
<   %.reg2mem = alloca i32, align 4
<   %.reg2mem3 = alloca i64, align 8
<   %.reg2mem6 = alloca i32, align 4
<   %.reg2mem8 = alloca i32*, align 8
<   %.reg2mem11 = alloca i64, align 8
<   %.reg2mem16 = alloca i32*, align 8
<   %.reg2mem18 = alloca i8*, align 8
<   %.reg2mem22 = alloca i32, align 4
<   %.reg2mem24 = alloca i64, align 8
<   %"reg2mem alloca point" = bitcast i32 0 to i32
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   store i8* %1, i8** %.reg2mem18, align 8
<   %.reload21 = load i8*, i8** %.reg2mem18, align 8
<   %2 = bitcast i8* %.reload21 to i32*
<   store i32* %2, i32** %.reg2mem16, align 8
<   %.reload20 = load i8*, i8** %.reg2mem18, align 8
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %.reload20, i8 0, i64 4000, i1 false)
<   store i64 0, i64* %.reg2mem24, align 8
<   br label %3
< 
< 3:                                                ; preds = %._crit_edge, %0
<   %.reload25 = load i64, i64* %.reg2mem24, align 8
<   store i64 %.reload25, i64* %.reg2mem11, align 8
<   %.reload15 = load i64, i64* %.reg2mem11, align 8
<   %4 = trunc i64 %.reload15 to i32
<   %5 = urem i32 %4, 13
<   %.reload14 = load i64, i64* %.reg2mem11, align 8
<   %.reload17 = load i32*, i32** %.reg2mem16, align 8
<   %6 = getelementptr inbounds i32, i32* %.reload17, i64 %.reload14
<   store i32* %6, i32** %.reg2mem8, align 8
<   %.reload10 = load i32*, i32** %.reg2mem8, align 8
<   store i32 %5, i32* %.reload10, align 4, !tbaa !5
<   %.reload13 = load i64, i64* %.reg2mem11, align 8
<   %7 = trunc i64 %.reload13 to i32
<   store i32 %7, i32* %.reg2mem6, align 4
<   store i32 0, i32* %.reg2mem22, align 4
<   br label %12
< 
< 8:                                                ; preds = %12
<   %9 = call i32 @putchar(i32 10)
<   %.reload12 = load i64, i64* %.reg2mem11, align 8
<   %10 = add nuw nsw i64 %.reload12, 1
<   store i64 %10, i64* %.reg2mem3, align 8
<   %.reload4 = load i64, i64* %.reg2mem3, align 8
<   %11 = icmp eq i64 %.reload4, 1000
<   br i1 %11, label %20, label %._crit_edge, !llvm.loop !9
< 
< ._crit_edge:                                      ; preds = %8
<   %.reload5 = load i64, i64* %.reg2mem3, align 8
<   store i64 %.reload5, i64* %.reg2mem24, align 8
<   br label %3
< 
< 12:                                               ; preds = %._crit_edge1, %3
<   %.reload23 = load i32, i32* %.reg2mem22, align 4
<   %.reload7 = load i32, i32* %.reg2mem6, align 4
<   %13 = add nuw nsw i32 %.reload23, %.reload7
---
>   br label %1
> 
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
67,84c30,36
<   %.reload9 = load i32*, i32** %.reg2mem8, align 8
<   %15 = load i32, i32* %.reload9, align 4, !tbaa !5
<   %16 = mul nsw i32 %15, %14
<   %17 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %16)
<   %18 = add nuw nsw i32 %.reload23, 1
<   store i32 %18, i32* %.reg2mem, align 4
<   %.reload = load i32, i32* %.reg2mem, align 4
<   %19 = icmp eq i32 %.reload, 1000
<   br i1 %19, label %8, label %._crit_edge1, !llvm.loop !12
< 
< ._crit_edge1:                                     ; preds = %12
<   %.reload2 = load i32, i32* %.reg2mem, align 4
<   store i32 %.reload2, i32* %.reg2mem22, align 4
<   br label %12
< 
< 20:                                               ; preds = %8
<   %.reload19 = load i8*, i8** %.reg2mem18, align 8
<   call void @_ZdaPv(i8* noundef %.reload19) #7
---
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
88,93d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
95,98c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
101c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
104,110c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
120,127c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/gvn.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,37c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %8, %0
<   %4 = phi i64 [ 0, %0 ], [ %10, %8 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   br label %12
< 
< 8:                                                ; preds = %12
<   %9 = call i32 @putchar(i32 10)
<   %10 = add nuw nsw i64 %4, 1
<   %11 = icmp eq i64 %10, 1000
<   br i1 %11, label %20, label %3, !llvm.loop !9
< 
< 12:                                               ; preds = %12, %3
<   %13 = phi i32 [ 0, %3 ], [ %18, %12 ]
<   %14 = add nuw nsw i32 %13, %5
<   %15 = urem i32 %14, 20
<   %16 = mul nsw i32 %6, %15
<   %17 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %16)
<   %18 = add nuw nsw i32 %13, 1
<   %19 = icmp eq i32 %18, 1000
<   br i1 %19, label %8, label %12, !llvm.loop !12
---
>   br label %1
39,40c12,36
< 20:                                               ; preds = %8
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
44,49d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
51,54c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
57c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
60,66c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
76,83c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/globaldce.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/adce.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/simplifycfg.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-extract.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,32c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %codeRepl
< 
< 9:                                                ; preds = %codeRepl
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %13, label %3, !llvm.loop !9
< 
< codeRepl:                                         ; preds = %3
<   call void @main.extracted(i32 %8, i32* %7)
<   br label %9
---
>   br label %1
34,35c12,36
< 13:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
39,44d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
46,49c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
52,72c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
< 
< ; Function Attrs: mustprogress norecurse uwtable
< define internal void @main.extracted(i32 %0, i32* %1) #0 {
< newFuncRoot:
<   br label %2
< 
< 2:                                                ; preds = %newFuncRoot, %2
<   %3 = phi i32 [ 0, %newFuncRoot ], [ %9, %2 ]
<   %4 = add nuw nsw i32 %3, %0
<   %5 = urem i32 %4, 20
<   %6 = load i32, i32* %1, align 4, !tbaa !5
<   %7 = mul nsw i32 %6, %5
<   %8 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %7)
<   %9 = add nuw nsw i32 %3, 1
<   %10 = icmp eq i32 %9, 1000
<   br i1 %10, label %.exitStub, label %2, !llvm.loop !12
< 
< .exitStub:                                        ; preds = %2
<   ret void
< }
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
75,81c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
91,98c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/strip-dead-prototypes.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/instcombine.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/aggressive-instcombine.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/mergefunc.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/simple-loop-unswitch.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/memcpyopt.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-reduce.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,42c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %8, %0
<   %4 = phi i64 [ 0, %0 ], [ %10, %8 ]
<   %lsr5 = trunc i64 %4 to i32
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   br label %12
< 
< 8:                                                ; preds = %12
<   %9 = call i32 @putchar(i32 10)
<   %10 = add nuw nsw i64 %4, 1
<   %11 = icmp eq i64 %10, 1000
<   br i1 %11, label %20, label %3, !llvm.loop !9
< 
< 12:                                               ; preds = %12, %3
<   %lsr.iv3 = phi i32 [ %lsr.iv.next4, %12 ], [ %lsr5, %3 ]
<   %lsr.iv = phi i32 [ %lsr.iv.next, %12 ], [ 1000, %3 ]
<   %13 = udiv i32 %lsr.iv3, 20
<   %14 = mul nuw i32 %13, 20
<   %15 = sub i32 %lsr.iv3, %14
<   %16 = load i32, i32* %7, align 4, !tbaa !5
<   %17 = mul nsw i32 %16, %15
<   %18 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %17)
<   %lsr.iv.next = add nsw i32 %lsr.iv, -1
<   %lsr.iv.next4 = add nuw nsw i32 %lsr.iv3, 1
<   %19 = icmp eq i32 %lsr.iv.next, 0
<   br i1 %19, label %8, label %12, !llvm.loop !12
---
>   br label %1
44,45c12,36
< 20:                                               ; preds = %8
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
49,54d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
56,59c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
62c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
65,71c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
81,88c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/sink.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/mem2reg.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/dse.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/lcssa.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/internalize.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
9,39c9,10
< define internal noundef i32 @main() local_unnamed_addr #0 {
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
> define dso_local noundef i32 @main() local_unnamed_addr #0 {
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/constmerge.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/strip-debug-declare.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loweratomic.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/lowerswitch.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/ipsccp.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/tailcallelim.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = tail call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = tail call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   tail call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/strip.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
6c6
< @0 = private unnamed_addr constant [4 x i8] c"%d \00", align 1
---
> @.str = private unnamed_addr constant [4 x i8] c"%d \00", align 1
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @0, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/strip-dead-debug-info.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/indvars.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/loop-rotate.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/jump-threading.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/dce.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


1c1
< ; ModuleID = './understand-elf/pass-test/lowerinvoke.bc'
---
> ; ModuleID = './understand-elf/matmul-v2.cpp'
10,39c10
<   %1 = call noalias noundef nonnull dereferenceable(4000) i8* @_Znam(i64 noundef 4000) #6
<   %2 = bitcast i8* %1 to i32*
<   call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(4000) %1, i8 0, i64 4000, i1 false)
<   br label %3
< 
< 3:                                                ; preds = %9, %0
<   %4 = phi i64 [ 0, %0 ], [ %11, %9 ]
<   %5 = trunc i64 %4 to i32
<   %6 = urem i32 %5, 13
<   %7 = getelementptr inbounds i32, i32* %2, i64 %4
<   store i32 %6, i32* %7, align 4, !tbaa !5
<   %8 = trunc i64 %4 to i32
<   br label %13
< 
< 9:                                                ; preds = %13
<   %10 = call i32 @putchar(i32 10)
<   %11 = add nuw nsw i64 %4, 1
<   %12 = icmp eq i64 %11, 1000
<   br i1 %12, label %22, label %3, !llvm.loop !9
< 
< 13:                                               ; preds = %13, %3
<   %14 = phi i32 [ 0, %3 ], [ %20, %13 ]
<   %15 = add nuw nsw i32 %14, %8
<   %16 = urem i32 %15, 20
<   %17 = load i32, i32* %7, align 4, !tbaa !5
<   %18 = mul nsw i32 %17, %16
<   %19 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %18)
<   %20 = add nuw nsw i32 %14, 1
<   %21 = icmp eq i32 %20, 1000
<   br i1 %21, label %9, label %13, !llvm.loop !12
---
>   br label %1
41,42c12,36
< 22:                                               ; preds = %9
<   call void @_ZdaPv(i8* noundef %1) #7
---
> 1:                                                ; preds = %0, %7
>   %2 = phi i64 [ 0, %0 ], [ %9, %7 ]
>   %3 = trunc i64 %2 to i32
>   %4 = trunc i64 %2 to i16
>   %5 = urem i16 %4, 13
>   %6 = zext i16 %5 to i32
>   br label %11
> 
> 7:                                                ; preds = %11
>   %8 = tail call i32 @putchar(i32 10)
>   %9 = add nuw nsw i64 %2, 1
>   %10 = icmp eq i64 %9, 1000
>   br i1 %10, label %19, label %1, !llvm.loop !5
> 
> 11:                                               ; preds = %1, %11
>   %12 = phi i32 [ 0, %1 ], [ %17, %11 ]
>   %13 = add nuw nsw i32 %12, %3
>   %14 = urem i32 %13, 20
>   %15 = mul nuw nsw i32 %14, %6
>   %16 = tail call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15)
>   %17 = add nuw nsw i32 %12, 1
>   %18 = icmp eq i32 %17, 1000
>   br i1 %18, label %7, label %11, !llvm.loop !7
> 
> 19:                                               ; preds = %7
46,51d39
< ; Function Attrs: nobuiltin allocsize(0)
< declare noundef nonnull i8* @_Znam(i64 noundef) local_unnamed_addr #1
< 
< ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
< declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2
< 
53,56c41
< declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #3
< 
< ; Function Attrs: nobuiltin nounwind
< declare void @_ZdaPv(i8* noundef) local_unnamed_addr #4
---
> declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #1
59c44
< declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #5
---
> declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #2
62,68c47,48
< attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
< attributes #3 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #4 = { nobuiltin nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
< attributes #5 = { nofree nounwind }
< attributes #6 = { builtin allocsize(0) }
< attributes #7 = { builtin nounwind }
---
> attributes #1 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
> attributes #2 = { nofree nounwind }
78,85c58,60
< !5 = !{!6, !6, i64 0}
< !6 = !{!"int", !7, i64 0}
< !7 = !{!"omnipotent char", !8, i64 0}
< !8 = !{!"Simple C++ TBAA"}
< !9 = distinct !{!9, !10, !11}
< !10 = !{!"llvm.loop.mustprogress"}
< !11 = !{!"llvm.loop.unroll.disable"}
< !12 = distinct !{!12, !10, !11}
---
> !5 = distinct !{!5, !6}
> !6 = !{!"llvm.loop.mustprogress"}
> !7 = distinct !{!7, !6}


